/*
 * Copyright Â© 2017 Atomist, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { EditProject } from '@atomist/rug/operations/ProjectEditor'
import { Project } from '@atomist/rug/model/Project'
import { Editor, Tags } from '@atomist/rug/operations/Decorators'
import { PathExpressionEngine } from '@atomist/rug/tree/PathExpression'
import { File } from '@atomist/rug/model/File'

@Editor("TestsToTypeScript", "convert Rug DSL BDD tests to TypeScript")
@Tags("rug", "atomist", "typescript")
export class TestsToTypeScript implements EditProject {

    variablesToString(variables: string[]): string {
        return variables.map(p => "    " + p + ";").join("\n");
    }

    edit(project: Project) {
        let eng: PathExpressionEngine = project.context().pathExpressionEngine();
        eng.with<File>(project, "/*[@name='.atomist']/tests/*", f => {
            if (! /\.rt$/.test(f.path())) {
                return;
            }

            let gherkinPath = f.path().replace(/tests\/([A-Za-z0-9]*)\.rt$/, "tests/project/$1Test.feature");
            let tsPath = f.path().replace(/tests\/([A-Za-z0-9]*)\.rt$/, "tests/project/$1Test.ts");
            if (project.fileExists(gherkinPath) || project.fileExists(tsPath)) {
                console.log(`converted version of ${f.path()} exists`);
                return;
            }

            console.log(`Converting ${f.path()}`);

            let lines = f.content().split("\n");

            let featureText = `Feature: Tests from ${f.name()}
  This file was autogenerated.
  It aims to avoid collisions, not remove redundancy.
  You can probably consolidate a lot of the elements.

`;
            let gherkin: string[] = [featureText];
            let tsImports = `import { Project } from "@atomist/rug/model/Project";
import { Given, When, Then, ProjectScenarioWorld } from "@atomist/rug/test/project/Core";
`;
            let ts: string[] = [tsImports];
            let scenario: string = "";
            let variables: string[] = [];

            for (let i = 0; i < lines.length; ++i) {
                if (lines[i].substr(1, 1) == "*") {
                    if (lines[i].substr(0, 1) != "/" && lines[i].substr(2, 1) != "/") {
                        gherkin.push("#" + lines[i].substr(2));
                    }
                    ts.push(lines[i]);
                } else if (/^\s*scenario\b/.test(lines[i])) {
                    scenario = lines[i].replace(/^\s*scenario\s+/, "");
                    gherkin.push("\n\n  Scenario: " + scenario);
                    variables = [];
                } else if (/^\s*let\b/.test(lines[i])) {
                    variables.push(lines[i]);
                } else if (/^\s*given\b/.test(lines[i])) {
                    let givenGherkinLines: string[] = [];
                    let givenTsLines: string[] = [];
                    lines[i] = lines[i].replace(/^\s*given\s*/, "");
                    for (; ! /^\s*when\b/.test(lines[i]); ++i) {
                        if (/^\s*"[^"]+"\s*=/.test(lines[i])) {
                            let fileMatch = /"([^"]+)"/.exec(lines[i]);
                            let filePath = "";
                            if (fileMatch != null) {
                                if (fileMatch.length < 2) {
                                    console.log("failed to capture file name:" + lines[i]);
                                } else {
                                    filePath = fileMatch[1];
                                }
                            } else {
                                console.log("failed to match file name:" + lines[i]);
                                continue;
                            }
                            let contents = "";
                            if (/=\s*"""/.test(lines[i])) {
                                let contentsMatch = /"""(.*)"""/.exec(lines[i]);
                                if (contentsMatch != null) {
                                    if (contentsMatch.length < 2) {
                                        console.log("failed to capture file contents:" + lines[i]);
                                        continue;
                                    }
                                    contents = contentsMatch[1];
                                } else {
                                    let contentsMatch = /"""(.*)/.exec(lines[i]);
                                    if (contentsMatch == null || contentsMatch.length < 2) {
                                        console.log("failed to match something we already matched:" + lines[i]);
                                        continue;
                                    }
                                    contents = contentsMatch[1] + "\n";
                                    for (++i; ! /""\"/.test(lines[i]); ++i) {
                                        contents += lines[i] + "\n";
                                    }
                                    let lastMatch = /(.+)"""/.exec(lines[i]);
                                    if (lastMatch != null && lastMatch.length > 1) {
                                        contents += lastMatch[1] + "\n";
                                    }
                                }
                            } else if (/=\s*"/.test(lines[i])) {
                                let contentsMatch = /"(.*)"/.exec(lines[i]);
                                if (contentsMatch != null && contentsMatch.length > 1) {
                                    contents = contentsMatch[1];
                                } else {
                                    console.log("failed to match contents:" + lines[i]);
                                    continue;
                                }
                            } else {
                                console.log("unrecognized given file:" + lines[i]);
                            }
                            let givenName = `a file named ${filePath} for ${scenario}`;
                            givenGherkinLines.push(givenName);
                            givenTsLines.push(`Given("${givenName}", p => { p.addFile("${filePath}", \`${contents}\`) });`, "");
                        } else if (/\s*Empty\b/.test(lines[i])) {
                            let givenName = "nothing for " + scenario;
                            givenGherkinLines.push(givenName);
                            givenTsLines.push(`Given("${givenName}", p => { });`, "");
                        } else if (/\s*ArchiveRoot\b/.test(lines[i])) {
                            let givenName = 'archive root for ' + scenario;
                            givenGherkinLines.push(givenName);
                            givenTsLines.push(`Given("${givenName}", p => { p.copyEditorBackingFilesPreservingPath(""); });`, "");
                        } else if (lines[i].length > 0) {
                            console.log("failed to match given line:" + lines[i]);
                        }
                    }
                    --i;
                    for (let g of givenGherkinLines) {
                        gherkin.push("    Given " + g);
                    }
                    ts = ts.concat(givenTsLines);
                } else if (/^\s*when\b/.test(lines[i])) {
                    lines[i] = lines[i].replace(/^\s*when\s*/, "");
                    let whenArgs: string[] = [];
                    for (; ! /^\s*then\b/.test(lines[i]); ++i) {
                        if (! /\S/.test(lines[i])) {
                            continue;
                        }
                        whenArgs.push(lines[i].trim());
                    }
                    --i;

                    let whenArg = whenArgs.join(" ")
                    let whenTitle = whenArg.replace(/=/g, "is").replace(/["']/g, "") + " for " + scenario;;
                    let whenMatches = /^\s*([A-Z]\w*)\b(.*)$/.exec(whenArg);
                    if (whenMatches == null || whenMatches.length < 3) {
                        console.log("failed to match when:" + whenArg);
                        continue;
                    }
                    let editor = whenMatches[1];
                    // let parameterRegex = /\s*([A-Za-z_]\w*)\s*=\s*("[^"]*"|'[^']*'|[A-Za-z_]\w*|-?(?:\d+|\d*.\d+))\s*/g;
                    let parameters = whenMatches[2].trim().replace(/\s*=\s*/g, ": ");
                    let varParams: string[] = variables.map(p => {
                        return p.trim().replace(/^\s*let\s*/, "").replace(/\s*=\s*/, ": ");
                    });
                    if (parameters) {
                        varParams.unshift(parameters);
                    }
                    parameters = varParams.join(", ");
                    let varString = this.variablesToString(variables);
                    let tsWhen = `When("${whenTitle}", (p, world) => {
    let psworld = world as ProjectScenarioWorld;
    let editor = psworld.editor("${editor}");
${varString}
    psworld.editWith(editor, { ${parameters} });
});`;

                    gherkin.push("    When " + whenTitle);
                    ts.push(tsWhen, "");
                } else if (/^\s*then\b/.test(lines[i])) {
                    lines[i] = lines[i].replace(/\s*then\s*/, "");
                    for (; i < lines.length && ! /^\s*scenario\b/.test(lines[i]); ++i) {
                        if (! /\S/.test(lines[i])) {
                            continue;
                        }
                        let predicateString = lines[i].trim().replace(/^and\s+/, "");
                        let predicateName = predicateString.replace(/["'{}]/g, "").replace(/!/g, "not ").trim()
                            + " for " + scenario;
                        let predicate = "";
                        if (predicateString == "NoChange") {
                            predicateName = "no change for " + scenario;
                            predicate = `!world.modificationsMade()`;
                        } else if (/^\{/.test(predicateString)) {
                            predicate = predicateString.substr(1).replace(/\}\s*$/, "").trim().replace(/result/g, "p");
                        } else {
                            let predicateMatch = /^(\w+)\s+(.*)\s*$/.exec(predicateString);
                            if (predicateMatch == null || predicateMatch.length < 3) {
                                console.log("failed to match predicate:" + predicateString);
                                continue;
                            }
                            let fName = predicateMatch[1];
                            let fParams = predicateMatch[2];
                            let paramRegex = /("[^"]*"|'[^']*'|[A-Za-z_]\w*|\{[^}]*\})/g;
                            let paramMatch: string[];
                            let parameters: string[] = [];
                            while (paramMatch = paramRegex.exec(fParams)) {
                                let p = paramMatch[1].replace(/^{\s*/, "").replace(/\s*}$/, "");
                                parameters.push(p);
                            }
                            predicate = `p.${fName}(${parameters.join(", ")})`;
                        }
                        gherkin.push("    Then " + predicateName);
                        let varString = this.variablesToString(variables);
                        let tsThen = (`Then("${predicateName}", (p, world) => {
${varString}
    return ${predicate};
});`);
                        ts.push(tsThen, "");
                    }
                    --i;
                } else if (lines[i].length > 0) {
                    gherkin.push("# " + lines[i]);
                }
            }

            project.addFile(gherkinPath, gherkin.join("\n") + "\n");
            project.addFile(tsPath, ts.join("\n") + "\n");
        });
    }
}

export const testsToTypeScript = new TestsToTypeScript();
